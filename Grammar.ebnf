module ::= moduleclause (';' definitions|'where' '{' definitions '}')|'{' definitions '}'
definitions ::= definition (semicoli definitions?)?
definition ::= DOCUMENTATION definition?|topdefinition|visibledefinition
topdefinition ::= import|fixity operators|NATIVE PACKAGE typeclause interfaces 'where' '{' jtokens? '}'|publicdefinition
visibledefinition ::= (PRIVATE|PROTECTED|PUBLIC) publicdefinition|ABSTRACT datainit wheredef
publicdefinition ::= typedef|(datainit|INSTANCE insthead) wheredef|classdef|DERIVE insthead|localdef
classdef ::= CLASS ccontext ('=>' CONID tyvar)? wheredef
datadef ::= datainit wheredef
instdef ::= INSTANCE insthead wheredef
wheredef ::= ('where' '{' localdefs? '}')?
localdefs ::= dplocaldef (semicoli localdefs?)?
dplocaldef ::= DOCUMENTATION dplocaldef?|plocaldef
plocaldef ::= (PRIVATE|PROTECTED|PUBLIC)? localdef
localdef ::= annotation|PURE? NATIVE methodspec '::' sigexs|fundef
appex ::= appex? unex
lambdabody ::= '\' apats lambdabody|'->' expr
getfield ::= VARID (('<-'|'=') expr)?
getfields ::= getfield (',' getfields?)?
dodefs ::= lcqual (semicoli dodefs?)?
lcqual ::= gqual|expr '=' expr|LET '{' letdefs '}'
lcquals ::= lcqual (',' lcquals?)?
exprSS ::= expr (';' exprSS?)?
exprSC ::= expr (',' exprSC?)?
field ::= VARID ('=' expr)?
fields ::= field (',' fields?)?
term ::= qvarid|literal|'_'|qconid ('{' fields? '}')?|'(' ((commata|'!'|'?'|'-')?|SOMEOP expr?|binex (SOMEOP|'-')|expr (',' exprSC|';' exprSS)?) ')'|'[' ((expr '|' lcquals)?|exprSC ('..' expr?)?) ']'
primary ::= term|(DO '{' dodefs|qualifiers '{' (VARID ('?'|'='|'<-')|getfields)) '}'|primary '.' (VARID|SOMEOP|'!'|'?'|'{' (VARID ('?'|'='|'<-')|getfields) '}'|'[' expr ']')
unex ::= primary|('!'|'?') unex
apats ::= unex apats?
lambda ::= '\' apats lambdabody
wherelet ::= 'where' '{' letdefs? '}'
gqual ::= expr ('<-' expr)?
gquals ::= gqual (',' gquals?)?
guard ::= '|' gquals ('->'|'=') expr
guards ::= '|' gquals aeq expr guards?
funhead ::= binex
fundef ::= binex ('=' expr|guards)|fundef WHERE '{' letdefs? '}'
letdef ::= annotation|fundef
letdefs ::= (annotation|fundef) (semicoli letdefs?)?
calts ::= calt (';' calts?)?
topex ::= ('if' expr ';'? 'then' expr ';'? 'else'|LET '{' letdefs '}' IN) expr|'case' expr OF '{' calts '}'|'\' apats lambdabody|appex
binex ::= binex (SOMEOP|'-') binex|'-'? topex
expr ::= binex ('::' (forall|rho))?
pattern ::= expr
calt ::= expr (('->'|'=') expr|guards)|calt WHERE '{' letdefs? '}'
aeq ::= '->'|'='
import ::= IMPORT modulename1 (VARID? CONID)? importliste
importliste ::= ((VARID '(' importspecs|'(' importspecs?) ')'|PUBLIC importliste)?
importspecs ::= importspec (',' importspecs?)?
importspec ::= importitem (VARID|CONID|SOMEOP)?|PUBLIC importspec
importitem ::= qvarid|CONID '(' memspecs? ')'|qconid|SOMEOP|'!'|'?'
memspecs ::= memspec (',' memspecs?)?
memspec ::= (VARID|CONID|SOMEOP) (VARID|CONID|SOMEOP)?|PUBLIC memspec
alias ::= VARID|CONID|SOMEOP
annotation ::= annoitems '::' (forall|rho)
annoitems ::= annoitem (',' annoitems)?
nativedef ::= PURE? NATIVE methodspec '::' sigexs
impurenativedef ::= NATIVE methodspec '::' sigexs
methodspec ::= fitem ((rawnativename|SOMEOP|'!'|'?') ('{' tauSC? '}')?|'{' tauSC? '}')?
fitem ::= annoitem|'!'|'?'|'-'|SOMEOP
annoitem ::= VARID|'(' (SOMEOP|'!'|'?'|'-') ')'
datainit ::= DATA CONID dvars? '=' (nativepur nativespec|dalts)|NEWTYPE CONID dvars? '=' dalt
dalts ::= dalt ('|' dalts)?
dalt ::= visdalt DOCUMENTATION?|DOCUMENTATION visdalt
visdalt ::= (PUBLIC|PRIVATE|PROTECTED)? strictdalt
strictdalt ::= ('!'|'?')? simpledalt
simpledalt ::= CONID ('{' conflds '}'|simpletypes)?
conflds ::= confld ((','|DOCUMENTATION) conflds?)?
confld ::= docs? fldids '::' (forall|rho)
sigexs ::= sigex ('|' sigexs)?
sigex ::= (forall|rho) (THROWS tauSC)?
typedef ::= TYPE CONID dvars? '=' (forall|rho)
sigma ::= forall|rho
derivedef ::= DERIVE insthead
insthead ::= icontext ('=>' tyname simpletype)?
icontext ::= qconid simpletype|'(' sicontexts ')'
sicontexts ::= qconid simpletype (',' sicontexts?)?
sicontext ::= qconid simpletype
contypes ::= simpletypes
nativespec ::= rawnativename ('{' tauSC? '}')?
gargs ::= '{' tauSC? '}'
moduledefinition ::= NATIVE PACKAGE typeclause interfaces 'where' '{' jtokens? '}'
interfaces ::= (CLASS tauSC)?
typeclause ::= (TYPE tau)?
rhofun ::= simpletypes ('->' rhofun)?
tauSB ::= tau ('|' tauSB)?
tauSC ::= tau (',' tauSC)?
tau ::= simpletypes ('->' tau)?|forall
simpletype ::= tyvar|tyname|'(' tau (',' tauSC|'|' tauSB)? ')'|'[' tau ']'
simpletypes ::= simpletype simpletypes?
tapp ::= simpletypes
rho ::= (simpletypes '=>')? rhofun
forall ::= FORALL boundvars ('.'|SOMEOP) rho
boundvars ::= VARID boundvars?
boundvar ::= VARID
ccontext ::= qconid tyvar|'(' scontexts ')'
tyname ::= qconid|'[' ']'|'(' (commata|'->')? ')'
commata ::= ',' commata?
moduleclause ::= docs? PROTECTED? PACKAGE modulename1|moduleclause words '(' qvarids ')'
docs ::= DOCUMENTATION (semicoli? docs)?
documentation ::= DOCUMENTATION
dvars ::= tyvar dvars?
elsex ::= ';'? 'else'
infix ::= fixity operators
fixity ::= (INFIX|INFIXL|INFIXR) INTCONST
fldids ::= fldid (',' fldids)?
fldid ::= (PUBLIC|PRIVATE)? strictfldid
jitem ::= rawnativename|SOMEOP|'!'|'?'
wheretokens ::= 'where' '{' jtokens? '}'
jtokens ::= (jtoken|'{' jtokens? '}') jtokens?
jtoken ::= VARID|CONID|QVARID|QCONID|CONID '.'|DOCUMENTATION|PACKAGE|IMPORT|INFIX|INFIXR|INFIXL|NATIVE|DATA|'where'|CLASS|INSTANCE|ABSTRACT|TYPE|TRUE|FALSE|'if'|'then'|'else'|'case'|OF|DERIVE|LET|IN|DO|FORALL|PRIVATE|PROTECTED|PUBLIC|PURE|THROWS|MUTABLE|INTCONST|STRCONST|LONGCONST|FLTCONST|DBLCONST|CHRCONST|'->'|'::'|'<-'|'=>'|'..'|SOMEOP|INTERPRET|','|'|'|'['|']'|'('|')'|'.'|'?'|'-'|';'|'!'|'='|'\'
scontexts ::= qconid tyvar (',' scontexts?)?
scontext ::= qconid tyvar
tyvar ::= VARID|'(' VARID '::' kind ')'
simplekind ::= SOMEOP|VARID|'(' kind ')'
kind ::= simplekind ('->' kind)?
literal ::= TRUE|FALSE|CHRCONST|STRCONST|INTCONST|BIGCONST|LONGCONST|FLTCONST|DBLCONST|REGEXP
mbdot ::= '.'|SOMEOP
modulename ::= modulename1
modulename1 ::= CONID|(varidkw '.'|CONID '.') modulename1
nativename ::= rawnativename
nativepur ::= (PURE|MUTABLE)? NATIVE
operators ::= (SOMEOP|VARID|'-') operators?
opstring ::= SOMEOP|VARID|'-'
qvarids ::= qvarop (',' qvarids)?
qvarop ::= (CONID '.' (CONID '.')?)? (VARID|'!'|'?')|SOMEOP
operator ::= SOMEOP
strictfldid ::= ('!'|'?')? VARID
plainfldid ::= VARID
qconid ::= (CONID '.' (CONID '.')?)? CONID
qualifiers ::= CONID '.' (CONID '.')?
qvarid ::= CONID '.' (CONID '.')? (VARID|'!'|'?')|VARID
rawnativename ::= (VARID|PACKAGE) ('.' rawnativename)?|CONID|CONID '.' rawnativename|STRCONST
semicoli ::= ';' semicoli?
thenx ::= ';'? 'then'
varop ::= VARID|'!'|'?'
unop ::= '!'|'?'
varid ::= VARID
varidkw ::= VARID|DATA|TYPE|NATIVE|PURE|PACKAGE|IMPORT
words ::= VARID words?
word ::= VARID
GETS ::= '<-'
THEN ::= 'then'
CONID ::= (UppercaseLetter|'_') (Letter|Digit|'_'|"'")*
IF ::= 'if'
DCOLON ::= '::'
ELSE ::= 'else'
UppercaseLetter ::= '«any character in Unicode categories Letter and Uppercase»'
LowercaseLetter ::= '«any character in Unicode categories Letter and not Uppercase»'
CASE ::= 'case'
Digit ::= [0-9]
QUALIFIER ::= CONID '.'
ARROW ::= '->'
WHERE ::= 'where'
Letter ::= '«any character in Unicode category: Letter»'
EARROW ::= '=>'
VARID ::= (LowercaseLetter|'_') (Letter|Digit|'_'|"'")*
DOTDOT ::= '..'

