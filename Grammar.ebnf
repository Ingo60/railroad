module ::= moduleclause (';' definitions|'where' '{' definitions '}')|'{' definitions '}'
definitions ::= definition (semicoli definitions?)?
definition ::= DOCUMENTATION definition?|visibledefinition|topdefinition
topdefinition ::= import|fixity operators|NATIVE PACKAGE typeclause interfaces 'where' '{' jtokens? '}'|publicdefinition
visibledefinition ::= (PRIVATE|PUBLIC|PROTECTED) publicdefinition|ABSTRACT datainit wheredef
publicdefinition ::= typedef|datainit wheredef|classdef|INSTANCE insthead wheredef|DERIVE insthead|localdef
classdef ::= CLASS ccontext (EARROW CONID tyvar)? wheredef
datadef ::= datainit wheredef
instdef ::= INSTANCE insthead wheredef
wheredef ::= ('where' '{' localdefs? '}')?
localdefs ::= dplocaldef (semicoli localdefs?)?
dplocaldef ::= DOCUMENTATION dplocaldef?|plocaldef
plocaldef ::= (PUBLIC|PROTECTED|PRIVATE)? localdef
localdef ::= annotation|PURE? impurenativedef|fundef
appex ::= appex? unex
lambdabody ::= '\' apats lambdabody|('->'|'→') expr
getfield ::= VARID (('<-'|'←'|'=') expr)?
getfields ::= getfield (',' getfields?)?
dodefs ::= lcqual (semicoli dodefs?)?
lcqual ::= gqual|expr '=' expr|LET '{' letdefs '}'
lcquals ::= lcqual (',' lcquals?)?
exprSS ::= expr (';' exprSS?)?
exprSC ::= expr (',' exprSC?)?
field ::= VARID ('=' expr)?
fields ::= field (',' fields?)?
term ::= qvarid|literal|'_'|qconid ('{' fields? '}')?|'[' ((expr '|' lcquals)? ']'|exprSC (']'|DOTDOT expr? ']'))|'(' (('-'|'!'|'?'|commata)? ')'|binex ('-'|SOMEOP) ')'|SOMEOP expr? ')'|expr (';' exprSS|',' exprSC)? ')')
primary ::= term|DO '{' dodefs '}'|primary '.' (VARID|SOMEOP|'!'|'?'|'{' (VARID ('?'|'<-'|'←'|'=') '}'|getfields '}')|'[' expr ']')|qualifiers '{' (getfields '}'|VARID ('<-'|'←'|'='|'?') '}')
unex ::= primary|('!'|'?') unex
apats ::= unex apats?
lambda ::= '\' apats lambdabody
wherelet ::= 'where' '{' letdefs? '}'
gqual ::= expr (('<-'|'←') expr)?
gquals ::= gqual (',' gquals?)?
guard ::= '|' gquals ('->'|'→'|'=') expr
guards ::= '|' gquals aeq expr guards?
funhead ::= binex
fundef ::= binex ('=' expr|guards)|fundef wherelet
letdef ::= annotation|fundef
letdefs ::= (annotation|fundef) (semicoli letdefs?)?
calts ::= calt (';' calts?)?
topex ::= (IF expr ';'? THEN expr ';'? ELSE|LET '{' letdefs '}' IN) expr|appex|'\' apats lambdabody|CASE expr OF '{' calts '}'
binex ::= binex (SOMEOP|'-') binex|'-'? topex
expr ::= binex (('::'|'∷') (forall|rho))?
pattern ::= expr
calt ::= expr (('->'|'→'|'=') expr|guards)|calt wherelet
aeq ::= '->'|'→'|'='
import ::= IMPORT modulename1 (VARID? CONID)? importliste
importliste ::= (VARID '(' importspecs ')'|'(' importspecs? ')'|PUBLIC importliste)?
importspecs ::= importspec (',' importspecs?)?
importspec ::= importitem (VARID|CONID|SOMEOP)?|PUBLIC importspec
importitem ::= qvarid|CONID '(' memspecs? ')'|'!'|'?'|SOMEOP|qconid
memspecs ::= memspec (',' memspecs?)?
memspec ::= (VARID|CONID|SOMEOP) (VARID|CONID|SOMEOP)?|PUBLIC memspec
alias ::= VARID|CONID|SOMEOP
annotation ::= annoitems ('::'|'∷') (forall|rho)
annoitems ::= annoitem (',' annoitems)?
nativedef ::= PURE? impurenativedef
impurenativedef ::= NATIVE methodspec ('::'|'∷') sigexs
methodspec ::= fitem ((rawnativename|SOMEOP|'!'|'?') ('{' tauSC? '}')?|'{' tauSC? '}')?
fitem ::= annoitem|'!'|'?'|'-'|SOMEOP
annoitem ::= VARID|'(' (SOMEOP|'!'|'?'|'-') ')'
datainit ::= DATA CONID ('=' (nativepur nativespec|dalts)|dvars '=' (dalts|nativepur nativespec))|NEWTYPE CONID dvars? '=' dalt
dalts ::= dalt ('|' dalts)?
dalt ::= visdalt DOCUMENTATION?|DOCUMENTATION visdalt
visdalt ::= (PROTECTED|PRIVATE|PUBLIC)? strictdalt
strictdalt ::= ('!'|'?')? simpledalt
simpledalt ::= CONID (simpletypes|'{' conflds '}')?
conflds ::= confld ((DOCUMENTATION|',') conflds?)?
confld ::= docs? fldids ('::'|'∷') (forall|rho)
sigexs ::= sigex ('|' sigexs)?
sigex ::= (forall|rho) (THROWS tauSC)?
typedef ::= TYPE CONID dvars? '=' (forall|rho)
sigma ::= forall|rho
derivedef ::= DERIVE insthead
insthead ::= icontext (EARROW tyname simpletype)?
icontext ::= qconid simpletype|'(' sicontexts ')'
sicontexts ::= qconid simpletype (',' sicontexts?)?
sicontext ::= qconid simpletype
contypes ::= simpletypes
nativespec ::= rawnativename ('{' tauSC? '}')?
gargs ::= '{' tauSC? '}'
moduledefinition ::= NATIVE PACKAGE typeclause interfaces 'where' '{' jtokens? '}'
interfaces ::= (CLASS tauSC)?
typeclause ::= (TYPE tau)?
rhofun ::= simpletypes (('->'|'→') rhofun)?
tauSB ::= tau ('|' tauSB)?
tauSC ::= tau (',' tauSC)?
tau ::= simpletypes (('->'|'→') tau)?|FORALL boundvars mbdot rho
simpletype ::= tyvar|tyname|'(' tau ('|' tauSB|',' tauSC)? ')'|'[' tau ']'
simpletypes ::= simpletype simpletypes?
tapp ::= simpletypes
rho ::= (simpletypes EARROW)? rhofun
forall ::= FORALL boundvars ('.'|SOMEOP) rho
boundvars ::= VARID boundvars?
boundvar ::= VARID
ccontext ::= qconid tyvar|'(' scontexts ')'
tyname ::= qconid|'[' ']'|'(' (commata|'->'|'→')? ')'
commata ::= ',' commata?
moduleclause ::= docs PROTECTED? PACKAGE modulename1|moduleclause words '(' qvarids ')'|PROTECTED? PACKAGE modulename1
docs ::= DOCUMENTATION (semicoli? docs)?
documentation ::= DOCUMENTATION
dvars ::= tyvar dvars?
elsex ::= ';'? ELSE
infix ::= fixity operators
fixity ::= (INFIX|INFIXR|INFIXL) INTCONST
fldids ::= fldid (',' fldids)?
fldid ::= (PRIVATE|PUBLIC)? strictfldid
jitem ::= rawnativename|SOMEOP|'!'|'?'
wheretokens ::= 'where' '{' jtokens? '}'
jtokens ::= jtoken jtokens?|'{' jtokens? '}' jtokens?
jtoken ::= VARID|CONID|QVARID|QCONID|CONID '.'|DOCUMENTATION|PACKAGE|IMPORT|INFIX|INFIXR|INFIXL|NATIVE|DATA|'where'|CLASS|INSTANCE|ABSTRACT|TYPE|TRUE|FALSE|IF|THEN|ELSE|CASE|OF|DERIVE|LET|IN|DO|FORALL|PRIVATE|PROTECTED|PUBLIC|PURE|THROWS|MUTABLE|INTCONST|STRCONST|LONGCONST|FLTCONST|DBLCONST|CHRCONST|'->'|'→'|'::'|'∷'|'<-'|'←'|EARROW|DOTDOT|SOMEOP|INTERPRET|','|'|'|'['|']'|'('|')'|'.'|'?'|'-'|';'|'!'|'='|'\'
scontexts ::= qconid tyvar (',' scontexts?)?
scontext ::= qconid tyvar
tyvar ::= VARID|'(' VARID ('::'|'∷') kind ')'
simplekind ::= SOMEOP|VARID|'(' kind ')'
kind ::= simplekind (('->'|'→') kind)?
literal ::= TRUE|FALSE|CHRCONST|STRCONST|INTCONST|BIGCONST|LONGCONST|FLTCONST|DBLCONST|REGEXP
mbdot ::= '.'|SOMEOP
modulename ::= modulename1
modulename1 ::= CONID|(varidkw '.'|CONID '.') modulename1
nativename ::= rawnativename
nativepur ::= (PURE|MUTABLE)? NATIVE
operators ::= (SOMEOP|VARID|'-') operators?
opstring ::= SOMEOP|VARID|'-'
qvarids ::= qvarop (',' qvarids)?
qvarop ::= CONID '.' (CONID '.')? (VARID|'!'|'?')|SOMEOP|VARID|'!'|'?'
operator ::= SOMEOP
strictfldid ::= ('?'|'!')? VARID
plainfldid ::= VARID
qconid ::= CONID '.' (CONID '.')? CONID|CONID
qualifiers ::= CONID '.' (CONID '.')?
qvarid ::= CONID '.' (CONID '.')? (VARID|'!'|'?')|VARID
rawnativename ::= (VARID|PACKAGE) ('.' rawnativename)?|CONID|CONID '.' rawnativename|STRCONST
semicoli ::= ';' semicoli?
thenx ::= ';'? THEN
varop ::= VARID|'!'|'?'
unop ::= '!'|'?'
varid ::= VARID
varidkw ::= VARID|DATA|TYPE|NATIVE|PURE|PACKAGE|IMPORT
words ::= VARID words?
word ::= VARID
GETS ::= '<-'|'←'
DCOLON ::= '::'|'∷'
LowercaseLetter ::= '«any character in Unicode category: Letter, Lowercase»'
QUALIFIER ::= CONID '.'
ARROW ::= '->'|'→'
WHERE ::= 'where'
Letter ::= '«any character in Unicode category: Letter»'
VARID ::= (LowercaseLetter|'_') (Letter|'_'|"'")*

